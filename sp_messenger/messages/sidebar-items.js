window.SIDEBAR_ITEMS = {"enum":[["Payload","Payload of the message"],["ProtocolMessageRequest","Defines protocol requests performed on domains."],["RequestResponse","Protocol message that encompasses  request or its response."],["VersionedPayload","Versioned message payload"]],"struct":[["CoreDomainStateRootStorage","This is a representation of actual StateRoots storage in pallet-receipts. Any change in key or value there should be changed here accordingly."],["CrossDomainMessage","Cross Domain message contains Message and its proof on src_domain."],["DomainBlockInfo","Domain block info used as part of the Cross domain message proof."],["ExecutionFee","Execution Fee to execute a send or receive request."],["ExtractedStateRootsFromProof","Holds the Block info and state roots from which a proof was constructed."],["FeeModel","Fee model to send a request and receive a response from another domain. A user of the endpoint will pay - outbox_fee on src_domain - inbox_fee on dst_domain The reward is distributed to - src_domain relayer pool when the response is received - dst_domain relayer pool when the response acknowledgement from src_domain."],["InitiateChannelParams","Parameters for a new channel between two domains."],["Message","Message contains information to be sent to or received from another domain"],["Proof","Proof combines the storage proofs to validate messages."],["RelayerMessageWithStorageKey","Relayer message with storage key to generate storage proof using the backend."],["RelayerMessagesWithStorageKey","Set of messages with storage keys to be relayed by a given relayer."]],"type":[["ChannelId","Channel identity."],["MessageId","Unique Id of a message between two domains."],["Nonce","Nonce used as an identifier and ordering of messages within a channel. Nonce is always increasing."],["ProtocolMessageResponse","Defines protocol requests performed on domains."]]};