mod handler;
mod protocol;

use crate::peer_info::handler::HandlerInEvent;
use handler::Handler;
pub use handler::{Config, PeerInfoError, Success};
use libp2p::core::{Endpoint, Multiaddr};
use libp2p::swarm::behaviour::{ConnectionEstablished, FromSwarm};
use libp2p::swarm::{
    ConnectionDenied, ConnectionId, NetworkBehaviour, NotifyHandler, PollParameters, THandler,
    THandlerInEvent, THandlerOutEvent, ToSwarm,
};
use libp2p::PeerId;
use parity_scale_codec::{Decode, Encode};
use std::collections::VecDeque;
use std::task::{Context, Poll};
use tracing::debug;

pub use self::protocol::PROTOCOL_NAME;

// TODO: comments - #![warn(missing_docs)]
// TODO: logs

// #[derive(Debug)]
// pub struct Behaviour {
//     /// Protocol name.
//     protocol_name: &'static [u8],
// }

// TODO: peerId, addresses
#[derive(Clone, Debug, Encode, Decode)]
pub struct PeerInfo {
    pub role: PeerRole,
}

impl Default for PeerInfo {
    fn default() -> Self {
        PeerInfo {
            role: PeerRole::Client,
        }
    }
}

#[derive(Clone, Debug, Encode, Decode)]
pub enum PeerRole {
    Farmer,
    Node,
    BootstrapNode,
    Client,
}

// /// Peer-info protocol configuration.
// #[derive(Debug, Clone)]
// pub struct Config {
//     /// Protocol name.
//     pub protocol_name: &'static [u8],
// }

/// The result of an inbound or outbound ping.
pub type Result = std::result::Result<Success, PeerInfoError>;

/// A [`NetworkBehaviour`] that responds to inbound pings and
/// periodically sends outbound pings on every established connection.
///
/// See the crate root documentation for more information.
pub struct Behaviour {
    /// Configuration for outbound pings.
    config: Config,
    /// Queue of events to yield to the swarm.
    events: VecDeque<Event>,

    requests: Vec<Request>,
}

#[derive(Debug, PartialEq, Eq)]
struct Request {
    peer_id: PeerId,
}

/// Event generated by the `Ping` network behaviour.
#[derive(Debug)]
pub struct Event {
    /// The peer ID of the remote.
    pub peer: PeerId,
    /// The result of an inbound or outbound ping.
    pub result: Result,
}

impl Behaviour {
    /// Creates a new `Ping` network behaviour with the given configuration.
    pub fn new(config: Config) -> Self {
        Self {
            config,
            events: VecDeque::new(),
            requests: Vec::new(),
        }
    }
}

impl Default for Behaviour {
    fn default() -> Self {
        Self::new(Config::new())
    }
}

impl NetworkBehaviour for Behaviour {
    type ConnectionHandler = Handler;
    type OutEvent = Event;

    fn handle_established_inbound_connection(
        &mut self,
        _: ConnectionId,
        _: PeerId,
        _: &Multiaddr,
        _: &Multiaddr,
    ) -> std::result::Result<THandler<Self>, ConnectionDenied> {
        Ok(Handler::new(self.config.clone()))
    }

    fn handle_established_outbound_connection(
        &mut self,
        _: ConnectionId,
        _: PeerId,
        _: &Multiaddr,
        _: Endpoint,
    ) -> std::result::Result<THandler<Self>, ConnectionDenied> {
        Ok(Handler::new(self.config.clone()))
    }

    fn on_connection_handler_event(
        &mut self,
        peer: PeerId,
        _: ConnectionId,
        result: THandlerOutEvent<Self>,
    ) {
        self.events.push_front(Event { peer, result })
    }

    fn poll(
        &mut self,
        _: &mut Context<'_>,
        _: &mut impl PollParameters,
    ) -> Poll<ToSwarm<Self::OutEvent, THandlerInEvent<Self>>> {
        if let Some(e) = self.events.pop_back() {
            let Event { result, peer } = &e;

            match result {
                Ok(Success::Ping { .. }) => debug!("Ping sent to {:?}", peer),
                Ok(Success::Pong) => debug!("Ping received from {:?}", peer),
                _ => {}
            }

            return Poll::Ready(ToSwarm::GenerateEvent(e));
        }

        // Check for pending requests.
        if let Some(Request { peer_id }) = self.requests.pop() {
            return Poll::Ready(ToSwarm::NotifyHandler {
                peer_id,
                handler: NotifyHandler::Any,
                event: HandlerInEvent,
            });
        }

        Poll::Pending
    }

    fn on_swarm_event(&mut self, event: FromSwarm<Self::ConnectionHandler>) {
        match event {
            FromSwarm::ConnectionEstablished(ConnectionEstablished {
                peer_id,
                other_established,
                ..
            }) => {
                if other_established == 0 {
                    self.requests.push(Request { peer_id });
                }
            }
            FromSwarm::ConnectionClosed(_)
            | FromSwarm::AddressChange(_)
            | FromSwarm::DialFailure(_)
            | FromSwarm::ListenFailure(_)
            | FromSwarm::NewListener(_)
            | FromSwarm::NewListenAddr(_)
            | FromSwarm::ExpiredListenAddr(_)
            | FromSwarm::ListenerError(_)
            | FromSwarm::ListenerClosed(_)
            | FromSwarm::NewExternalAddr(_)
            | FromSwarm::ExpiredExternalAddr(_) => {}
        }
    }
}
